* Higher level control of SynthDefs

#+BEGIN_SRC ruby
(
SynthDef(\blip, {|out = 0, amp = 0.6, dur = 1, freq = 1|
	var sig, env;
	env = EnvGen.kr(Env.perc(0.01, dur), doneAction:2); //take care of doneAction!
	sig = SinOsc.ar([120.0, 121.0] * freq); //two output sine oscillator synth.
	sig = sig / 2;
	Out.ar(out, sig * amp * env); //out creates a buss.
}).add;
)

(
SynthDef(\crackle, {|out = 0, chaos = 1.5, amp = 0.6, envDur = 0.3|
	var env, sig;
	env = EnvGen.kr(Env.sine(envDur), doneAction:2);
	sig = Crackle.ar(chaos, 0.5, 0.5);
	sig = sig.dup / 2; //duplicating the signal so it plays in both channels.
	Out.ar(out, sig * amp * env);
}).add;
)
#+END_SRC 

Run this only to make sure that the SynthDefs are loaded and sound...

#+BEGIN_SRC ruby
x = Synth(\blip, [\amp, 0.4, \out, 0, \dur, 1.0.rand]); //create an instance of 'drony' and assign it on a global var 'x'
y = Synth(\sawy, [\amp, 0.4, \out, 0, \dur, 10, \speed, 10]); //create an instance of 'saw' and assign it on a global var 'y'
#+END_SRC

** Events, streams and patterns.
Patterns in SuperCollider are streams of values and are a very powerful way to
control parameters of SynthDefs. There are various implementation of patterns,
from random distribution to sequential distribution of values.

#+BEGIN_SRC ruby
a = Pseq([1, 2, 3, 4], inf).asStream; //sequence of values from 1 to 4.
a.next; // run the sequence using. `.next` method.
#+END_SRC

*** Using a Pbind to control the SynthDefs.
Pbind is a wrapper for Events in SuperCollider. It takes couple of standard
arguments needed for the Pbind, such as duration and the name of the SynthDef, denoted a prefix
\instrument, for example to control the blip SynthDef we do it like this:
`\instrument, \blip`. The Pbind may have all or some arguments contained in the
SynthDef or just the ones we are trying to interact with.

**** Pbind example 
#+BEGIN_SRC ruby
Pbind(\instrument, \blip, \dur, 0.25, \freq, 1).play;
Pbind(\instrument, \blip, \dur, 0.25, \freq, 2).play; Pbind(\instrument, \blip,
\dur, 0.5, \freq, 0.5).play;


Pbind(\instrument, \sawy, \dur, 0.1, \speed, 2, \freq, 3).play;
Pbind(\instrument, \sawy, \dur, 0.01, \speed, 2, \freq, 1).play;
#+END_SRC

To change something without stopping the sound use a Pdef.
**** Pdef example
#+BEGIN_SRC ruby
Pdef(\x).play;
Pdef(\x,  Pbind(\instrument, \crackle, \dur, 2));
Pdef(\x, Pbind(\instrument, \crackle, \chaos, Pwhite(0.1, 2.0, inf),  \envDur, 0.3, \dur, 0.08));
#+END_SRC

***** ...and change things 'on the fly'
#+BEGIN_SRC ruby
Pdef(\y, Pbind(\instrument, \blip, \dur, Pbrown(0, 6, 0.1, inf), \freq, 2));
Pdef(\y).play;
Pdef(\x).stop;
Pdef(\y).stop;
#+END_SRC

** Discussion
Patterns are used to control SynthDefs in a higher level; SuperCollider provides
a lot of pattern implementations, including sequential and random generators.
Using them one can create various sonic and musical gestures which can be used
as boiler code for live improvisation and/or generate audio material for fixed
media composition. Thus, patterns are very powerful interface to interact with
various SynthDefs and can act as a very expressive tool for laptop improvisation
with SuperCollider.

** Assignment
Create couple of SynthDefs and control them with Pdef and Pbind assigning
different patterns on SynthDef parameters.

